/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.6.0.0 (NJsonSchema v10.1.18.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class AuthClient {
    constructor(private apiUrl: string) {
    }

    getBaseUrl(defaultUrl: string, requestedUrl?: string) {
        return requestedUrl ? requestedUrl : this.apiUrl;
    }

    transformHttpRequestOptions(options: RequestInit): Promise<RequestInit> {
        return Promise.resolve(options);
    }
}

export class ApiClientBase {
    constructor(private authClient: AuthClient) {

    }

    getBaseUrl(defaultUrl: string, requestedUrl?: string) {
        return this.authClient ? this.authClient.getBaseUrl(defaultUrl, requestedUrl) : defaultUrl;
    }

    transformOptions(options: RequestInit): Promise<RequestInit> {
        return this.authClient ? this.authClient.transformHttpRequestOptions(options) : Promise.resolve(options);
    }
}

export class DiaryClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    addRecord(systolicBloodPressure: number | null | undefined, diastolicBloodPressure: number | null | undefined, description: string | null | undefined, ambulanceDrugsNumber: number | null | undefined, pulse: number | null | undefined, glucoseLevel: number | null | undefined, date: Date | null | undefined, isMorning: boolean | null | undefined): Promise<DiaryAddRecordResponse> {
        let url_ = this.baseUrl + "/api/Diary/AddRecord?";
        if (systolicBloodPressure !== undefined && systolicBloodPressure !== null)
            url_ += "SystolicBloodPressure=" + encodeURIComponent("" + systolicBloodPressure) + "&";
        if (diastolicBloodPressure !== undefined && diastolicBloodPressure !== null)
            url_ += "DiastolicBloodPressure=" + encodeURIComponent("" + diastolicBloodPressure) + "&";
        if (description !== undefined && description !== null)
            url_ += "Description=" + encodeURIComponent("" + description) + "&";
        if (ambulanceDrugsNumber !== undefined && ambulanceDrugsNumber !== null)
            url_ += "AmbulanceDrugsNumber=" + encodeURIComponent("" + ambulanceDrugsNumber) + "&";
        if (pulse !== undefined && pulse !== null)
            url_ += "Pulse=" + encodeURIComponent("" + pulse) + "&";
        if (glucoseLevel !== undefined && glucoseLevel !== null)
            url_ += "GlucoseLevel=" + encodeURIComponent("" + glucoseLevel) + "&";
        if (date !== undefined && date !== null)
            url_ += "Date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&";
        if (isMorning !== undefined && isMorning !== null)
            url_ += "IsMorning=" + encodeURIComponent("" + isMorning) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddRecord(_response);
        });
    }

    protected processAddRecord(response: Response): Promise<DiaryAddRecordResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DiaryAddRecordResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DiaryAddRecordResponse>(<any>null);
    }

    getRecords(fromDate: Date | null | undefined, toDate: Date | null | undefined): Promise<DiaryGetRecordsResponse> {
        let url_ = this.baseUrl + "/api/Diary/GetRecords?";
        if (fromDate !== undefined && fromDate !== null)
            url_ += "FromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&";
        if (toDate !== undefined && toDate !== null)
            url_ += "ToDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRecords(_response);
        });
    }

    protected processGetRecords(response: Response): Promise<DiaryGetRecordsResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DiaryGetRecordsResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DiaryGetRecordsResponse>(<any>null);
    }
}

export class UserClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    login(email: string | null | undefined, password: string | null | undefined, rememberMe: boolean | undefined): Promise<UserLoginResponse> {
        let url_ = this.baseUrl + "/api/User/Login?";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (password !== undefined && password !== null)
            url_ += "Password=" + encodeURIComponent("" + password) + "&";
        if (rememberMe === null)
            throw new Error("The parameter 'rememberMe' cannot be null.");
        else if (rememberMe !== undefined)
            url_ += "RememberMe=" + encodeURIComponent("" + rememberMe) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLogin(_response);
        });
    }

    protected processLogin(response: Response): Promise<UserLoginResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserLoginResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserLoginResponse>(<any>null);
    }

    logout(): Promise<UserLogoutResponse> {
        let url_ = this.baseUrl + "/api/User/Logout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLogout(_response);
        });
    }

    protected processLogout(response: Response): Promise<UserLogoutResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserLogoutResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserLogoutResponse>(<any>null);
    }

    logoutFromAllDevices(): Promise<UserLogoutFromAllDevicesResponse> {
        let url_ = this.baseUrl + "/api/User/LogoutFromAllDevices";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLogoutFromAllDevices(_response);
        });
    }

    protected processLogoutFromAllDevices(response: Response): Promise<UserLogoutFromAllDevicesResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserLogoutFromAllDevicesResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserLogoutFromAllDevicesResponse>(<any>null);
    }

    register(birthDate: Date | null | undefined, isMen: boolean | null | undefined, userName: string | null | undefined, email: string | null | undefined, password: string | null | undefined): Promise<UserRegisterResponse> {
        let url_ = this.baseUrl + "/api/User/Register?";
        if (birthDate !== undefined && birthDate !== null)
            url_ += "BirthDate=" + encodeURIComponent(birthDate ? "" + birthDate.toJSON() : "") + "&";
        if (isMen !== undefined && isMen !== null)
            url_ += "IsMen=" + encodeURIComponent("" + isMen) + "&";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (password !== undefined && password !== null)
            url_ += "Password=" + encodeURIComponent("" + password) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<UserRegisterResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserRegisterResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserRegisterResponse>(<any>null);
    }

    confirmEmail(userId: string | null | undefined, confirmationToken: string | null | undefined): Promise<UserConfirmEmailResponse> {
        let url_ = this.baseUrl + "/api/User/ConfirmEmail?";
        if (userId !== undefined && userId !== null)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (confirmationToken !== undefined && confirmationToken !== null)
            url_ += "ConfirmationToken=" + encodeURIComponent("" + confirmationToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processConfirmEmail(_response);
        });
    }

    protected processConfirmEmail(response: Response): Promise<UserConfirmEmailResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserConfirmEmailResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserConfirmEmailResponse>(<any>null);
    }

    sendResetPasswordEmail(email: string | null | undefined, changePasswordUrl: string | null | undefined): Promise<UserSendResetPasswordEmailResponse> {
        let url_ = this.baseUrl + "/api/User/SendResetPasswordEmail?";
        if (email !== undefined && email !== null)
            url_ += "Email=" + encodeURIComponent("" + email) + "&";
        if (changePasswordUrl !== undefined && changePasswordUrl !== null)
            url_ += "ChangePasswordUrl=" + encodeURIComponent("" + changePasswordUrl) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSendResetPasswordEmail(_response);
        });
    }

    protected processSendResetPasswordEmail(response: Response): Promise<UserSendResetPasswordEmailResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserSendResetPasswordEmailResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserSendResetPasswordEmailResponse>(<any>null);
    }

    resetPassword(resetPasswordToken: string | null | undefined, newPassword: string | null | undefined): Promise<UserResetPasswordResponse> {
        let url_ = this.baseUrl + "/api/User/ResetPassword?";
        if (resetPasswordToken !== undefined && resetPasswordToken !== null)
            url_ += "ResetPasswordToken=" + encodeURIComponent("" + resetPasswordToken) + "&";
        if (newPassword !== undefined && newPassword !== null)
            url_ += "NewPassword=" + encodeURIComponent("" + newPassword) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: Response): Promise<UserResetPasswordResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserResetPasswordResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserResetPasswordResponse>(<any>null);
    }

    getInfo(): Promise<UserGetInfoResponse> {
        let url_ = this.baseUrl + "/api/User/GetInfo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetInfo(_response);
        });
    }

    protected processGetInfo(response: Response): Promise<UserGetInfoResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserGetInfoResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserGetInfoResponse>(<any>null);
    }

    edit(userName: string | null | undefined, birthDate: Date | null | undefined, isMen: boolean | null | undefined): Promise<UserEditResponse> {
        let url_ = this.baseUrl + "/api/User/Edit?";
        if (userName !== undefined && userName !== null)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (birthDate !== undefined && birthDate !== null)
            url_ += "BirthDate=" + encodeURIComponent(birthDate ? "" + birthDate.toJSON() : "") + "&";
        if (isMen !== undefined && isMen !== null)
            url_ += "IsMen=" + encodeURIComponent("" + isMen) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processEdit(_response);
        });
    }

    protected processEdit(response: Response): Promise<UserEditResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UserEditResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserEditResponse>(<any>null);
    }
}

export class GeneralMedicalContraindicationClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    getRecords(searchText: string | null | undefined): Promise<GeneralMedicalContraindicationResponse> {
        let url_ = this.baseUrl + "/api/dictionaries/GeneralMedicalContraindication/GetRecords?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRecords(_response);
        });
    }

    protected processGetRecords(response: Response): Promise<GeneralMedicalContraindicationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GeneralMedicalContraindicationResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GeneralMedicalContraindicationResponse>(<any>null);
    }
}

export class Mkb10Client extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    getRecords(searchText: string | null | undefined, skipCount: number | undefined, takeCount: number | undefined): Promise<Mkb10Response> {
        let url_ = this.baseUrl + "/api/dictionaries/Mkb10/GetRecords?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (takeCount === null)
            throw new Error("The parameter 'takeCount' cannot be null.");
        else if (takeCount !== undefined)
            url_ += "TakeCount=" + encodeURIComponent("" + takeCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRecords(_response);
        });
    }

    protected processGetRecords(response: Response): Promise<Mkb10Response> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Mkb10Response>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Mkb10Response>(<any>null);
    }
}

export class Order302NClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    getRecords(searchText: string | null | undefined): Promise<Order302NResponse> {
        let url_ = this.baseUrl + "/api/dictionaries/Order302N/GetRecords?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRecords(_response);
        });
    }

    protected processGetRecords(response: Response): Promise<Order302NResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Order302NResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Order302NResponse>(<any>null);
    }
}

export class Order417NClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    getRecords(searchText: string | null | undefined): Promise<Order417NResponse> {
        let url_ = this.baseUrl + "/api/dictionaries/Order417N/GetRecords?";
        if (searchText !== undefined && searchText !== null)
            url_ += "SearchText=" + encodeURIComponent("" + searchText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetRecords(_response);
        });
    }

    protected processGetRecords(response: Response): Promise<Order417NResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Order417NResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Order417NResponse>(<any>null);
    }
}

export class AntihypertensiveTherapyClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculateAntihypertensiveTherapy(age: number | undefined, isMen: boolean | undefined, systolicBloodPressure: number | undefined, diastolicBloodPressure: number | undefined, pulse: number | undefined, diseases: number[] | null | undefined): Promise<AntihypertensiveTherapyResponse> {
        let url_ = this.baseUrl + "/api/calculators/AntihypertensiveTherapy/CalculateAntihypertensiveTherapy?";
        if (age === null)
            throw new Error("The parameter 'age' cannot be null.");
        else if (age !== undefined)
            url_ += "Age=" + encodeURIComponent("" + age) + "&";
        if (isMen === null)
            throw new Error("The parameter 'isMen' cannot be null.");
        else if (isMen !== undefined)
            url_ += "IsMen=" + encodeURIComponent("" + isMen) + "&";
        if (systolicBloodPressure === null)
            throw new Error("The parameter 'systolicBloodPressure' cannot be null.");
        else if (systolicBloodPressure !== undefined)
            url_ += "SystolicBloodPressure=" + encodeURIComponent("" + systolicBloodPressure) + "&";
        if (diastolicBloodPressure === null)
            throw new Error("The parameter 'diastolicBloodPressure' cannot be null.");
        else if (diastolicBloodPressure !== undefined)
            url_ += "DiastolicBloodPressure=" + encodeURIComponent("" + diastolicBloodPressure) + "&";
        if (pulse === null)
            throw new Error("The parameter 'pulse' cannot be null.");
        else if (pulse !== undefined)
            url_ += "Pulse=" + encodeURIComponent("" + pulse) + "&";
        if (diseases !== undefined && diseases !== null)
            diseases && diseases.forEach(item => { url_ += "Diseases=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculateAntihypertensiveTherapy(_response);
        });
    }

    protected processCalculateAntihypertensiveTherapy(response: Response): Promise<AntihypertensiveTherapyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AntihypertensiveTherapyResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AntihypertensiveTherapyResponse>(<any>null);
    }

    getDiseases(): Promise<IdValueItemOfIntegerAndString[]> {
        let url_ = this.baseUrl + "/api/calculators/AntihypertensiveTherapy/GetDiseases";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetDiseases(_response);
        });
    }

    protected processGetDiseases(response: Response): Promise<IdValueItemOfIntegerAndString[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IdValueItemOfIntegerAndString[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdValueItemOfIntegerAndString[]>(<any>null);
    }
}

export class BodyMassIndexClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculateBodyMassIndex(height: number | undefined, weight: number | undefined): Promise<BodyMassIndexResponse> {
        let url_ = this.baseUrl + "/api/calculators/BodyMassIndex/CalculateBodyMassIndex?";
        if (height === null)
            throw new Error("The parameter 'height' cannot be null.");
        else if (height !== undefined)
            url_ += "Height=" + encodeURIComponent("" + height) + "&";
        if (weight === null)
            throw new Error("The parameter 'weight' cannot be null.");
        else if (weight !== undefined)
            url_ += "Weight=" + encodeURIComponent("" + weight) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculateBodyMassIndex(_response);
        });
    }

    protected processCalculateBodyMassIndex(response: Response): Promise<BodyMassIndexResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BodyMassIndexResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BodyMassIndexResponse>(<any>null);
    }
}

export class CHA2DS2VAScClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculateCHA2DS2VASc(isInsult: boolean | undefined, isOld75: boolean | undefined, isOld65: boolean | undefined, isArterialHypertension: boolean | undefined, isDiabetes: boolean | undefined, isHeartFailure: boolean | undefined, isMyocardialInfarction: boolean | undefined, isWomen: boolean | undefined): Promise<CHA2DS2VAScResponse> {
        let url_ = this.baseUrl + "/api/calculators/CHA2DS2VASc/CalculateCHA2DS2VASc?";
        if (isInsult === null)
            throw new Error("The parameter 'isInsult' cannot be null.");
        else if (isInsult !== undefined)
            url_ += "IsInsult=" + encodeURIComponent("" + isInsult) + "&";
        if (isOld75 === null)
            throw new Error("The parameter 'isOld75' cannot be null.");
        else if (isOld75 !== undefined)
            url_ += "IsOld75=" + encodeURIComponent("" + isOld75) + "&";
        if (isOld65 === null)
            throw new Error("The parameter 'isOld65' cannot be null.");
        else if (isOld65 !== undefined)
            url_ += "IsOld65=" + encodeURIComponent("" + isOld65) + "&";
        if (isArterialHypertension === null)
            throw new Error("The parameter 'isArterialHypertension' cannot be null.");
        else if (isArterialHypertension !== undefined)
            url_ += "IsArterialHypertension=" + encodeURIComponent("" + isArterialHypertension) + "&";
        if (isDiabetes === null)
            throw new Error("The parameter 'isDiabetes' cannot be null.");
        else if (isDiabetes !== undefined)
            url_ += "IsDiabetes=" + encodeURIComponent("" + isDiabetes) + "&";
        if (isHeartFailure === null)
            throw new Error("The parameter 'isHeartFailure' cannot be null.");
        else if (isHeartFailure !== undefined)
            url_ += "IsHeartFailure=" + encodeURIComponent("" + isHeartFailure) + "&";
        if (isMyocardialInfarction === null)
            throw new Error("The parameter 'isMyocardialInfarction' cannot be null.");
        else if (isMyocardialInfarction !== undefined)
            url_ += "IsMyocardialInfarction=" + encodeURIComponent("" + isMyocardialInfarction) + "&";
        if (isWomen === null)
            throw new Error("The parameter 'isWomen' cannot be null.");
        else if (isWomen !== undefined)
            url_ += "IsWomen=" + encodeURIComponent("" + isWomen) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculateCHA2DS2VASc(_response);
        });
    }

    protected processCalculateCHA2DS2VASc(response: Response): Promise<CHA2DS2VAScResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CHA2DS2VAScResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CHA2DS2VAScResponse>(<any>null);
    }
}

export class ContrastInducedNephropathyClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculateContrastInducedNephropathy(isHypotonia: boolean | undefined, isVABK: boolean | undefined, isNYHA: boolean | undefined, isOldAge: boolean | undefined, isAnemya: boolean | undefined, isDiabetes: boolean | undefined, isBigCreatinin: boolean | undefined, volumeContrast: number | undefined, speedKF: number | undefined): Promise<ContrastInducedNephropathyResponse> {
        let url_ = this.baseUrl + "/api/calculators/ContrastInducedNephropathy/CalculateContrastInducedNephropathy?";
        if (isHypotonia === null)
            throw new Error("The parameter 'isHypotonia' cannot be null.");
        else if (isHypotonia !== undefined)
            url_ += "IsHypotonia=" + encodeURIComponent("" + isHypotonia) + "&";
        if (isVABK === null)
            throw new Error("The parameter 'isVABK' cannot be null.");
        else if (isVABK !== undefined)
            url_ += "IsVABK=" + encodeURIComponent("" + isVABK) + "&";
        if (isNYHA === null)
            throw new Error("The parameter 'isNYHA' cannot be null.");
        else if (isNYHA !== undefined)
            url_ += "IsNYHA=" + encodeURIComponent("" + isNYHA) + "&";
        if (isOldAge === null)
            throw new Error("The parameter 'isOldAge' cannot be null.");
        else if (isOldAge !== undefined)
            url_ += "IsOldAge=" + encodeURIComponent("" + isOldAge) + "&";
        if (isAnemya === null)
            throw new Error("The parameter 'isAnemya' cannot be null.");
        else if (isAnemya !== undefined)
            url_ += "IsAnemya=" + encodeURIComponent("" + isAnemya) + "&";
        if (isDiabetes === null)
            throw new Error("The parameter 'isDiabetes' cannot be null.");
        else if (isDiabetes !== undefined)
            url_ += "IsDiabetes=" + encodeURIComponent("" + isDiabetes) + "&";
        if (isBigCreatinin === null)
            throw new Error("The parameter 'isBigCreatinin' cannot be null.");
        else if (isBigCreatinin !== undefined)
            url_ += "IsBigCreatinin=" + encodeURIComponent("" + isBigCreatinin) + "&";
        if (volumeContrast === null)
            throw new Error("The parameter 'volumeContrast' cannot be null.");
        else if (volumeContrast !== undefined)
            url_ += "VolumeContrast=" + encodeURIComponent("" + volumeContrast) + "&";
        if (speedKF === null)
            throw new Error("The parameter 'speedKF' cannot be null.");
        else if (speedKF !== undefined)
            url_ += "SpeedKF=" + encodeURIComponent("" + speedKF) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculateContrastInducedNephropathy(_response);
        });
    }

    protected processCalculateContrastInducedNephropathy(response: Response): Promise<ContrastInducedNephropathyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ContrastInducedNephropathyResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ContrastInducedNephropathyResponse>(<any>null);
    }
}

export class CorrectedQTCalculationClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculateCorrectedQTCalculation(heartRate: number | undefined, intervalQT: number | undefined): Promise<CorrectedQTCalculationResponse> {
        let url_ = this.baseUrl + "/api/calculators/CorrectedQTCalculation/CalculateCorrectedQTCalculation?";
        if (heartRate === null)
            throw new Error("The parameter 'heartRate' cannot be null.");
        else if (heartRate !== undefined)
            url_ += "HeartRate=" + encodeURIComponent("" + heartRate) + "&";
        if (intervalQT === null)
            throw new Error("The parameter 'intervalQT' cannot be null.");
        else if (intervalQT !== undefined)
            url_ += "IntervalQT=" + encodeURIComponent("" + intervalQT) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculateCorrectedQTCalculation(_response);
        });
    }

    protected processCalculateCorrectedQTCalculation(response: Response): Promise<CorrectedQTCalculationResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CorrectedQTCalculationResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CorrectedQTCalculationResponse>(<any>null);
    }
}

export class GlasgoClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculateGlasgo(eyeResponse: number | undefined, verbalResponse: number | undefined, motorResponse: number | undefined): Promise<GlasgoResponse> {
        let url_ = this.baseUrl + "/api/calculators/Glasgo/CalculateGlasgo?";
        if (eyeResponse === null)
            throw new Error("The parameter 'eyeResponse' cannot be null.");
        else if (eyeResponse !== undefined)
            url_ += "EyeResponse=" + encodeURIComponent("" + eyeResponse) + "&";
        if (verbalResponse === null)
            throw new Error("The parameter 'verbalResponse' cannot be null.");
        else if (verbalResponse !== undefined)
            url_ += "VerbalResponse=" + encodeURIComponent("" + verbalResponse) + "&";
        if (motorResponse === null)
            throw new Error("The parameter 'motorResponse' cannot be null.");
        else if (motorResponse !== undefined)
            url_ += "MotorResponse=" + encodeURIComponent("" + motorResponse) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculateGlasgo(_response);
        });
    }

    protected processCalculateGlasgo(response: Response): Promise<GlasgoResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GlasgoResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GlasgoResponse>(<any>null);
    }
}

export class GlomerularFiltrationRateClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculateGlomerularFiltrationRate(creatinin: number | undefined, age: number | undefined, weight: number | undefined, height: number | undefined, isMen: boolean | undefined): Promise<GlomerularFiltrationRateResponse> {
        let url_ = this.baseUrl + "/api/calculators/GlomerularFiltrationRate/CalculateGlomerularFiltrationRate?";
        if (creatinin === null)
            throw new Error("The parameter 'creatinin' cannot be null.");
        else if (creatinin !== undefined)
            url_ += "Creatinin=" + encodeURIComponent("" + creatinin) + "&";
        if (age === null)
            throw new Error("The parameter 'age' cannot be null.");
        else if (age !== undefined)
            url_ += "Age=" + encodeURIComponent("" + age) + "&";
        if (weight === null)
            throw new Error("The parameter 'weight' cannot be null.");
        else if (weight !== undefined)
            url_ += "Weight=" + encodeURIComponent("" + weight) + "&";
        if (height === null)
            throw new Error("The parameter 'height' cannot be null.");
        else if (height !== undefined)
            url_ += "Height=" + encodeURIComponent("" + height) + "&";
        if (isMen === null)
            throw new Error("The parameter 'isMen' cannot be null.");
        else if (isMen !== undefined)
            url_ += "IsMen=" + encodeURIComponent("" + isMen) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculateGlomerularFiltrationRate(_response);
        });
    }

    protected processCalculateGlomerularFiltrationRate(response: Response): Promise<GlomerularFiltrationRateResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GlomerularFiltrationRateResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GlomerularFiltrationRateResponse>(<any>null);
    }
}

export class GraceScaleClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculateGraceScale(age: number | undefined, heartRate: number | undefined, systolicBloodPressure: number | undefined, creatinin: number | undefined, kilip: number | undefined, heartFailure: boolean | undefined, stSegmentDeviation: boolean | undefined, highLevelOfCardiacEnzymes: boolean | undefined): Promise<GraceScaleResponse> {
        let url_ = this.baseUrl + "/api/calculators/GraceScale/CalculateGraceScale?";
        if (age === null)
            throw new Error("The parameter 'age' cannot be null.");
        else if (age !== undefined)
            url_ += "Age=" + encodeURIComponent("" + age) + "&";
        if (heartRate === null)
            throw new Error("The parameter 'heartRate' cannot be null.");
        else if (heartRate !== undefined)
            url_ += "HeartRate=" + encodeURIComponent("" + heartRate) + "&";
        if (systolicBloodPressure === null)
            throw new Error("The parameter 'systolicBloodPressure' cannot be null.");
        else if (systolicBloodPressure !== undefined)
            url_ += "SystolicBloodPressure=" + encodeURIComponent("" + systolicBloodPressure) + "&";
        if (creatinin === null)
            throw new Error("The parameter 'creatinin' cannot be null.");
        else if (creatinin !== undefined)
            url_ += "Creatinin=" + encodeURIComponent("" + creatinin) + "&";
        if (kilip === null)
            throw new Error("The parameter 'kilip' cannot be null.");
        else if (kilip !== undefined)
            url_ += "Kilip=" + encodeURIComponent("" + kilip) + "&";
        if (heartFailure === null)
            throw new Error("The parameter 'heartFailure' cannot be null.");
        else if (heartFailure !== undefined)
            url_ += "HeartFailure=" + encodeURIComponent("" + heartFailure) + "&";
        if (stSegmentDeviation === null)
            throw new Error("The parameter 'stSegmentDeviation' cannot be null.");
        else if (stSegmentDeviation !== undefined)
            url_ += "StSegmentDeviation=" + encodeURIComponent("" + stSegmentDeviation) + "&";
        if (highLevelOfCardiacEnzymes === null)
            throw new Error("The parameter 'highLevelOfCardiacEnzymes' cannot be null.");
        else if (highLevelOfCardiacEnzymes !== undefined)
            url_ += "HighLevelOfCardiacEnzymes=" + encodeURIComponent("" + highLevelOfCardiacEnzymes) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculateGraceScale(_response);
        });
    }

    protected processCalculateGraceScale(response: Response): Promise<GraceScaleResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <GraceScaleResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<GraceScaleResponse>(<any>null);
    }

    getKillipDictionary(): Promise<IdValueItemOfIntegerAndString[]> {
        let url_ = this.baseUrl + "/api/calculators/GraceScale/GetKillipDictionary";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processGetKillipDictionary(_response);
        });
    }

    protected processGetKillipDictionary(response: Response): Promise<IdValueItemOfIntegerAndString[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IdValueItemOfIntegerAndString[]>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IdValueItemOfIntegerAndString[]>(<any>null);
    }
}

export class HASBLEDClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculateHASBLED(hypertension: boolean | undefined, creatinineIncreased: boolean | undefined, transaminase: boolean | undefined, insult: boolean | undefined, bleeding: boolean | undefined, mno: boolean | undefined, oldAge: boolean | undefined, antiplateletAgents: boolean | undefined, alcohol: boolean | undefined): Promise<HASBLEDResponse> {
        let url_ = this.baseUrl + "/api/calculators/HASBLED/CalculateHASBLED?";
        if (hypertension === null)
            throw new Error("The parameter 'hypertension' cannot be null.");
        else if (hypertension !== undefined)
            url_ += "Hypertension=" + encodeURIComponent("" + hypertension) + "&";
        if (creatinineIncreased === null)
            throw new Error("The parameter 'creatinineIncreased' cannot be null.");
        else if (creatinineIncreased !== undefined)
            url_ += "CreatinineIncreased=" + encodeURIComponent("" + creatinineIncreased) + "&";
        if (transaminase === null)
            throw new Error("The parameter 'transaminase' cannot be null.");
        else if (transaminase !== undefined)
            url_ += "Transaminase=" + encodeURIComponent("" + transaminase) + "&";
        if (insult === null)
            throw new Error("The parameter 'insult' cannot be null.");
        else if (insult !== undefined)
            url_ += "Insult=" + encodeURIComponent("" + insult) + "&";
        if (bleeding === null)
            throw new Error("The parameter 'bleeding' cannot be null.");
        else if (bleeding !== undefined)
            url_ += "Bleeding=" + encodeURIComponent("" + bleeding) + "&";
        if (mno === null)
            throw new Error("The parameter 'mno' cannot be null.");
        else if (mno !== undefined)
            url_ += "Mno=" + encodeURIComponent("" + mno) + "&";
        if (oldAge === null)
            throw new Error("The parameter 'oldAge' cannot be null.");
        else if (oldAge !== undefined)
            url_ += "OldAge=" + encodeURIComponent("" + oldAge) + "&";
        if (antiplateletAgents === null)
            throw new Error("The parameter 'antiplateletAgents' cannot be null.");
        else if (antiplateletAgents !== undefined)
            url_ += "AntiplateletAgents=" + encodeURIComponent("" + antiplateletAgents) + "&";
        if (alcohol === null)
            throw new Error("The parameter 'alcohol' cannot be null.");
        else if (alcohol !== undefined)
            url_ += "Alcohol=" + encodeURIComponent("" + alcohol) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculateHASBLED(_response);
        });
    }

    protected processCalculateHASBLED(response: Response): Promise<HASBLEDResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <HASBLEDResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HASBLEDResponse>(<any>null);
    }
}

export class IndexSmokeClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculateIndexSmoke(ageSmoke: number | undefined, countSigar: number | undefined): Promise<IndexSmokeResponse> {
        let url_ = this.baseUrl + "/api/calculators/IndexSmoke/CalculateIndexSmoke?";
        if (ageSmoke === null)
            throw new Error("The parameter 'ageSmoke' cannot be null.");
        else if (ageSmoke !== undefined)
            url_ += "AgeSmoke=" + encodeURIComponent("" + ageSmoke) + "&";
        if (countSigar === null)
            throw new Error("The parameter 'countSigar' cannot be null.");
        else if (countSigar !== undefined)
            url_ += "CountSigar=" + encodeURIComponent("" + countSigar) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculateIndexSmoke(_response);
        });
    }

    protected processCalculateIndexSmoke(response: Response): Promise<IndexSmokeResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IndexSmokeResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IndexSmokeResponse>(<any>null);
    }
}

export class InfusionRateClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculateInfusionRate(bodyMass: number | undefined, amountDrug: number | undefined, volumeSolution: number | undefined, dose: number | undefined): Promise<InfusionRateResponse> {
        let url_ = this.baseUrl + "/api/calculators/InfusionRate/CalculateInfusionRate?";
        if (bodyMass === null)
            throw new Error("The parameter 'bodyMass' cannot be null.");
        else if (bodyMass !== undefined)
            url_ += "BodyMass=" + encodeURIComponent("" + bodyMass) + "&";
        if (amountDrug === null)
            throw new Error("The parameter 'amountDrug' cannot be null.");
        else if (amountDrug !== undefined)
            url_ += "AmountDrug=" + encodeURIComponent("" + amountDrug) + "&";
        if (volumeSolution === null)
            throw new Error("The parameter 'volumeSolution' cannot be null.");
        else if (volumeSolution !== undefined)
            url_ += "VolumeSolution=" + encodeURIComponent("" + volumeSolution) + "&";
        if (dose === null)
            throw new Error("The parameter 'dose' cannot be null.");
        else if (dose !== undefined)
            url_ += "Dose=" + encodeURIComponent("" + dose) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculateInfusionRate(_response);
        });
    }

    protected processCalculateInfusionRate(response: Response): Promise<InfusionRateResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <InfusionRateResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<InfusionRateResponse>(<any>null);
    }
}

export class PotassiumDeficiencyClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculatePotassiumDeficiency(bloodKaliumLevel: number | undefined, bodyMass: number | undefined): Promise<PotassiumDeficiencyResponse> {
        let url_ = this.baseUrl + "/api/calculators/PotassiumDeficiency/CalculatePotassiumDeficiency?";
        if (bloodKaliumLevel === null)
            throw new Error("The parameter 'bloodKaliumLevel' cannot be null.");
        else if (bloodKaliumLevel !== undefined)
            url_ += "BloodKaliumLevel=" + encodeURIComponent("" + bloodKaliumLevel) + "&";
        if (bodyMass === null)
            throw new Error("The parameter 'bodyMass' cannot be null.");
        else if (bodyMass !== undefined)
            url_ += "BodyMass=" + encodeURIComponent("" + bodyMass) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculatePotassiumDeficiency(_response);
        });
    }

    protected processCalculatePotassiumDeficiency(response: Response): Promise<PotassiumDeficiencyResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PotassiumDeficiencyResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PotassiumDeficiencyResponse>(<any>null);
    }
}

export class ScoreScaleClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculateScoreScale(age: number | undefined, upperBloodPressure: number | undefined, plasmaCholesterol: number | undefined, isMen: boolean | undefined, isSmoke: boolean | undefined): Promise<ScoreScaleResponse> {
        let url_ = this.baseUrl + "/api/calculators/ScoreScale/CalculateScoreScale?";
        if (age === null)
            throw new Error("The parameter 'age' cannot be null.");
        else if (age !== undefined)
            url_ += "Age=" + encodeURIComponent("" + age) + "&";
        if (upperBloodPressure === null)
            throw new Error("The parameter 'upperBloodPressure' cannot be null.");
        else if (upperBloodPressure !== undefined)
            url_ += "UpperBloodPressure=" + encodeURIComponent("" + upperBloodPressure) + "&";
        if (plasmaCholesterol === null)
            throw new Error("The parameter 'plasmaCholesterol' cannot be null.");
        else if (plasmaCholesterol !== undefined)
            url_ += "PlasmaCholesterol=" + encodeURIComponent("" + plasmaCholesterol) + "&";
        if (isMen === null)
            throw new Error("The parameter 'isMen' cannot be null.");
        else if (isMen !== undefined)
            url_ += "IsMen=" + encodeURIComponent("" + isMen) + "&";
        if (isSmoke === null)
            throw new Error("The parameter 'isSmoke' cannot be null.");
        else if (isSmoke !== undefined)
            url_ += "IsSmoke=" + encodeURIComponent("" + isSmoke) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculateScoreScale(_response);
        });
    }

    protected processCalculateScoreScale(response: Response): Promise<ScoreScaleResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ScoreScaleResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScoreScaleResponse>(<any>null);
    }
}

export class SubstanceinSolutionClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculateSubstanceinSolution(procent: number | undefined, volume: number | undefined): Promise<SubstanceinSolutionResponse> {
        let url_ = this.baseUrl + "/api/calculators/SubstanceinSolution/CalculateSubstanceinSolution?";
        if (procent === null)
            throw new Error("The parameter 'procent' cannot be null.");
        else if (procent !== undefined)
            url_ += "Procent=" + encodeURIComponent("" + procent) + "&";
        if (volume === null)
            throw new Error("The parameter 'volume' cannot be null.");
        else if (volume !== undefined)
            url_ += "Volume=" + encodeURIComponent("" + volume) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculateSubstanceinSolution(_response);
        });
    }

    protected processCalculateSubstanceinSolution(response: Response): Promise<SubstanceinSolutionResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <SubstanceinSolutionResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SubstanceinSolutionResponse>(<any>null);
    }
}

export class TimiScaleClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculateTimiScale(oldAge: boolean | undefined, threeRisk: boolean | undefined, stenos: boolean | undefined, liftSt: boolean | undefined, stenocardia: boolean | undefined, aspirin: boolean | undefined, necroze: boolean | undefined): Promise<TimiScaleResponse> {
        let url_ = this.baseUrl + "/api/calculators/TimiScale/CalculateTimiScale?";
        if (oldAge === null)
            throw new Error("The parameter 'oldAge' cannot be null.");
        else if (oldAge !== undefined)
            url_ += "OldAge=" + encodeURIComponent("" + oldAge) + "&";
        if (threeRisk === null)
            throw new Error("The parameter 'threeRisk' cannot be null.");
        else if (threeRisk !== undefined)
            url_ += "ThreeRisk=" + encodeURIComponent("" + threeRisk) + "&";
        if (stenos === null)
            throw new Error("The parameter 'stenos' cannot be null.");
        else if (stenos !== undefined)
            url_ += "Stenos=" + encodeURIComponent("" + stenos) + "&";
        if (liftSt === null)
            throw new Error("The parameter 'liftSt' cannot be null.");
        else if (liftSt !== undefined)
            url_ += "LiftSt=" + encodeURIComponent("" + liftSt) + "&";
        if (stenocardia === null)
            throw new Error("The parameter 'stenocardia' cannot be null.");
        else if (stenocardia !== undefined)
            url_ += "Stenocardia=" + encodeURIComponent("" + stenocardia) + "&";
        if (aspirin === null)
            throw new Error("The parameter 'aspirin' cannot be null.");
        else if (aspirin !== undefined)
            url_ += "Aspirin=" + encodeURIComponent("" + aspirin) + "&";
        if (necroze === null)
            throw new Error("The parameter 'necroze' cannot be null.");
        else if (necroze !== undefined)
            url_ += "Necroze=" + encodeURIComponent("" + necroze) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculateTimiScale(_response);
        });
    }

    protected processCalculateTimiScale(response: Response): Promise<TimiScaleResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <TimiScaleResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TimiScaleResponse>(<any>null);
    }
}

export class CuperFormulaClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculate(height: number | undefined, isMen: boolean | undefined): Promise<CuperFormulaResponse> {
        let url_ = this.baseUrl + "/api/calculators/IdealBodyWeight/CuperFormula/Calculate?";
        if (height === null)
            throw new Error("The parameter 'height' cannot be null.");
        else if (height !== undefined)
            url_ += "Height=" + encodeURIComponent("" + height) + "&";
        if (isMen === null)
            throw new Error("The parameter 'isMen' cannot be null.");
        else if (isMen !== undefined)
            url_ += "IsMen=" + encodeURIComponent("" + isMen) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculate(_response);
        });
    }

    protected processCalculate(response: Response): Promise<CuperFormulaResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CuperFormulaResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CuperFormulaResponse>(<any>null);
    }
}

export class DevinFormulaClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculate(height: number | undefined, isMen: boolean | undefined): Promise<DevinFormulaResponse> {
        let url_ = this.baseUrl + "/api/calculators/IdealBodyWeight/DevinFormula/Calculate?";
        if (height === null)
            throw new Error("The parameter 'height' cannot be null.");
        else if (height !== undefined)
            url_ += "Height=" + encodeURIComponent("" + height) + "&";
        if (isMen === null)
            throw new Error("The parameter 'isMen' cannot be null.");
        else if (isMen !== undefined)
            url_ += "IsMen=" + encodeURIComponent("" + isMen) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculate(_response);
        });
    }

    protected processCalculate(response: Response): Promise<DevinFormulaResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DevinFormulaResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DevinFormulaResponse>(<any>null);
    }
}

export class EgorovaTableClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculate(height: number | undefined, isMen: boolean | undefined, age: number | undefined): Promise<EgorovaTableResponse> {
        let url_ = this.baseUrl + "/api/calculators/IdealBodyWeight/EgorovaTable/Calculate?";
        if (height === null)
            throw new Error("The parameter 'height' cannot be null.");
        else if (height !== undefined)
            url_ += "Height=" + encodeURIComponent("" + height) + "&";
        if (isMen === null)
            throw new Error("The parameter 'isMen' cannot be null.");
        else if (isMen !== undefined)
            url_ += "IsMen=" + encodeURIComponent("" + isMen) + "&";
        if (age === null)
            throw new Error("The parameter 'age' cannot be null.");
        else if (age !== undefined)
            url_ += "Age=" + encodeURIComponent("" + age) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculate(_response);
        });
    }

    protected processCalculate(response: Response): Promise<EgorovaTableResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EgorovaTableResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<EgorovaTableResponse>(<any>null);
    }
}

export class HamviFormulaClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculate(height: number | undefined, isMen: boolean | undefined): Promise<HamviFormulaResponse> {
        let url_ = this.baseUrl + "/api/calculators/IdealBodyWeight/HamviFormula/Calculate?";
        if (height === null)
            throw new Error("The parameter 'height' cannot be null.");
        else if (height !== undefined)
            url_ += "Height=" + encodeURIComponent("" + height) + "&";
        if (isMen === null)
            throw new Error("The parameter 'isMen' cannot be null.");
        else if (isMen !== undefined)
            url_ += "IsMen=" + encodeURIComponent("" + isMen) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculate(_response);
        });
    }

    protected processCalculate(response: Response): Promise<HamviFormulaResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <HamviFormulaResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<HamviFormulaResponse>(<any>null);
    }
}

export class IdealBodyWeightClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculateBorngardt(height: number | undefined, chestircumference: number | undefined): Promise<BorngardtResponse> {
        let url_ = this.baseUrl + "/api/calculators/IdealBodyWeight/CalculateBorngardt?";
        if (height === null)
            throw new Error("The parameter 'height' cannot be null.");
        else if (height !== undefined)
            url_ += "Height=" + encodeURIComponent("" + height) + "&";
        if (chestircumference === null)
            throw new Error("The parameter 'chestircumference' cannot be null.");
        else if (chestircumference !== undefined)
            url_ += "Chestircumference=" + encodeURIComponent("" + chestircumference) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculateBorngardt(_response);
        });
    }

    protected processCalculateBorngardt(response: Response): Promise<BorngardtResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BorngardtResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<BorngardtResponse>(<any>null);
    }
}

export class IndexBrokaBrukshaClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculate(height: number | undefined): Promise<IndexBrokaBrukshaResponse> {
        let url_ = this.baseUrl + "/api/calculators/IdealBodyWeight/IndexBrokaBruksha/Calculate?";
        if (height === null)
            throw new Error("The parameter 'height' cannot be null.");
        else if (height !== undefined)
            url_ += "Height=" + encodeURIComponent("" + height) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculate(_response);
        });
    }

    protected processCalculate(response: Response): Promise<IndexBrokaBrukshaResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IndexBrokaBrukshaResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IndexBrokaBrukshaResponse>(<any>null);
    }
}

export class IndexBrokaClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculate(height: number | undefined, isMen: boolean | undefined): Promise<IndexBrokaResponse> {
        let url_ = this.baseUrl + "/api/calculators/IdealBodyWeight/IndexBroka/Calculate?";
        if (height === null)
            throw new Error("The parameter 'height' cannot be null.");
        else if (height !== undefined)
            url_ += "Height=" + encodeURIComponent("" + height) + "&";
        if (isMen === null)
            throw new Error("The parameter 'isMen' cannot be null.");
        else if (isMen !== undefined)
            url_ += "IsMen=" + encodeURIComponent("" + isMen) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculate(_response);
        });
    }

    protected processCalculate(response: Response): Promise<IndexBrokaResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IndexBrokaResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IndexBrokaResponse>(<any>null);
    }
}

export class IndexSolovievaClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculateIndexSolovieva(isMen: boolean | undefined, wristLength: number | undefined): Promise<IndexSolovievaResponse> {
        let url_ = this.baseUrl + "/api/calculators/IndexSolovieva/CalculateIndexSolovieva?";
        if (isMen === null)
            throw new Error("The parameter 'isMen' cannot be null.");
        else if (isMen !== undefined)
            url_ += "IsMen=" + encodeURIComponent("" + isMen) + "&";
        if (wristLength === null)
            throw new Error("The parameter 'wristLength' cannot be null.");
        else if (wristLength !== undefined)
            url_ += "WristLength=" + encodeURIComponent("" + wristLength) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculateIndexSolovieva(_response);
        });
    }

    protected processCalculateIndexSolovieva(response: Response): Promise<IndexSolovievaResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <IndexSolovievaResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<IndexSolovievaResponse>(<any>null);
    }
}

export class KreffFormulaClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculate(height: number | undefined, age: number | undefined, lenarpus: number | undefined): Promise<KreffFormulaResponse> {
        let url_ = this.baseUrl + "/api/calculators/IdealBodyWeight/KreffFormula/Calculate?";
        if (height === null)
            throw new Error("The parameter 'height' cannot be null.");
        else if (height !== undefined)
            url_ += "Height=" + encodeURIComponent("" + height) + "&";
        if (age === null)
            throw new Error("The parameter 'age' cannot be null.");
        else if (age !== undefined)
            url_ += "Age=" + encodeURIComponent("" + age) + "&";
        if (lenarpus === null)
            throw new Error("The parameter 'lenarpus' cannot be null.");
        else if (lenarpus !== undefined)
            url_ += "Lenarpus=" + encodeURIComponent("" + lenarpus) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculate(_response);
        });
    }

    protected processCalculate(response: Response): Promise<KreffFormulaResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <KreffFormulaResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<KreffFormulaResponse>(<any>null);
    }
}

export class LorentzFormulaClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculateLorentzFormula(height: number | undefined, isMen: boolean | undefined): Promise<LorentzFormulaResponse> {
        let url_ = this.baseUrl + "/api/calculators/LorentzFormula/CalculateLorentzFormula?";
        if (height === null)
            throw new Error("The parameter 'height' cannot be null.");
        else if (height !== undefined)
            url_ += "Height=" + encodeURIComponent("" + height) + "&";
        if (isMen === null)
            throw new Error("The parameter 'isMen' cannot be null.");
        else if (isMen !== undefined)
            url_ += "IsMen=" + encodeURIComponent("" + isMen) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculateLorentzFormula(_response);
        });
    }

    protected processCalculateLorentzFormula(response: Response): Promise<LorentzFormulaResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LorentzFormulaResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LorentzFormulaResponse>(<any>null);
    }
}

export class MillerFormulaClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculate(height: number | undefined, isMen: boolean | undefined): Promise<MillerFormulaResponse> {
        let url_ = this.baseUrl + "/api/calculators/IdealBodyWeight/MillerFormula/Calculate?";
        if (height === null)
            throw new Error("The parameter 'height' cannot be null.");
        else if (height !== undefined)
            url_ += "Height=" + encodeURIComponent("" + height) + "&";
        if (isMen === null)
            throw new Error("The parameter 'isMen' cannot be null.");
        else if (isMen !== undefined)
            url_ += "IsMen=" + encodeURIComponent("" + isMen) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculate(_response);
        });
    }

    protected processCalculate(response: Response): Promise<MillerFormulaResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MillerFormulaResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MillerFormulaResponse>(<any>null);
    }
}

export class MochammedFormulaClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculate(height: number | undefined): Promise<MochammedFormulaResponse> {
        let url_ = this.baseUrl + "/api/calculators/IdealBodyWeight/MochammedFormula/Calculate?";
        if (height === null)
            throw new Error("The parameter 'height' cannot be null.");
        else if (height !== undefined)
            url_ += "Height=" + encodeURIComponent("" + height) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculate(_response);
        });
    }

    protected processCalculate(response: Response): Promise<MochammedFormulaResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MochammedFormulaResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MochammedFormulaResponse>(<any>null);
    }
}

export class MonnerotFormulaClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculate(height: number | undefined, wristLength: number | undefined): Promise<MonnerotFormulaResponse> {
        let url_ = this.baseUrl + "/api/calculators/IdealBodyWeight/MonnerotFormula/Calculate?";
        if (height === null)
            throw new Error("The parameter 'height' cannot be null.");
        else if (height !== undefined)
            url_ += "Height=" + encodeURIComponent("" + height) + "&";
        if (wristLength === null)
            throw new Error("The parameter 'wristLength' cannot be null.");
        else if (wristLength !== undefined)
            url_ += "WristLength=" + encodeURIComponent("" + wristLength) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculate(_response);
        });
    }

    protected processCalculate(response: Response): Promise<MonnerotFormulaResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <MonnerotFormulaResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MonnerotFormulaResponse>(<any>null);
    }
}

export class NaglerFormulaClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculate(height: number | undefined, isMen: boolean | undefined): Promise<NaglerFormulaResponse> {
        let url_ = this.baseUrl + "/api/calculators/IdealBodyWeight/NaglerFormula/Calculate?";
        if (height === null)
            throw new Error("The parameter 'height' cannot be null.");
        else if (height !== undefined)
            url_ += "Height=" + encodeURIComponent("" + height) + "&";
        if (isMen === null)
            throw new Error("The parameter 'isMen' cannot be null.");
        else if (isMen !== undefined)
            url_ += "IsMen=" + encodeURIComponent("" + isMen) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculate(_response);
        });
    }

    protected processCalculate(response: Response): Promise<NaglerFormulaResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <NaglerFormulaResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<NaglerFormulaResponse>(<any>null);
    }
}

export class RobinsonFormulaClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = this.getBaseUrl("", baseUrl);
    }

    calculate(height: number | undefined, isMen: boolean | undefined): Promise<RobinsonFormulaResponse> {
        let url_ = this.baseUrl + "/api/calculators/IdealBodyWeight/RobinsonFormula/Calculate?";
        if (height === null)
            throw new Error("The parameter 'height' cannot be null.");
        else if (height !== undefined)
            url_ += "Height=" + encodeURIComponent("" + height) + "&";
        if (isMen === null)
            throw new Error("The parameter 'isMen' cannot be null.");
        else if (isMen !== undefined)
            url_ += "IsMen=" + encodeURIComponent("" + isMen) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "POST",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCalculate(_response);
        });
    }

    protected processCalculate(response: Response): Promise<RobinsonFormulaResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <RobinsonFormulaResponse>JSON.parse(_responseText, this.jsonParseReviver);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<RobinsonFormulaResponse>(<any>null);
    }
}

export interface DiaryAddRecordResponse {
}

export interface DiaryGetRecordsResponse {
    records?: DiaryGetRecordsResponseRecord[] | undefined;
}

export interface DiaryGetRecordsResponseRecord {
    systolicBloodPressure: number;
    diastolicBloodPressure: number;
    description?: string | undefined;
    ambulanceDrugsNumber: number;
    pulse: number;
    glucoseLevel?: number | undefined;
    date: Date;
    isMorning: boolean;
}

export interface UserLoginResponse {
    token?: string | undefined;
    emailConfirmed: boolean;
}

export interface UserLogoutResponse {
}

export interface UserLogoutFromAllDevicesResponse {
}

export interface UserRegisterResponse {
    token?: string | undefined;
}

export interface UserConfirmEmailResponse {
}

export interface UserSendResetPasswordEmailResponse {
}

export interface UserResetPasswordResponse {
}

export interface UserGetInfoResponse {
    birthDate: Date;
    isMen: boolean;
    email?: string | undefined;
    userName?: string | undefined;
    emailConfirmed: boolean;
}

export interface UserEditResponse {
}

export interface GeneralMedicalContraindicationResponse {
    records?: GeneralMedicalContraindicationResponseRecord[] | undefined;
}

export interface GeneralMedicalContraindicationResponseRecord {
    id: number;
    pathology?: string | undefined;
}

export interface Mkb10Response {
    records?: Mkb10ResponseRecord[] | undefined;
    totalCount: number;
}

export interface Mkb10ResponseRecord {
    code?: string | undefined;
    name?: string | undefined;
}

export interface Order302NResponse {
    records?: Order302NResponseRecord[] | undefined;
}

export interface Order302NResponseRecord {
    point?: string | undefined;
    name?: string | undefined;
    inspectionFrequency?: string | undefined;
    additionalMedicalContraindications?: string | undefined;
    applicationItemNumber: number;
}

export interface Order417NResponse {
    records?: Order417NResponseRecord[] | undefined;
}

export interface Order417NResponseRecord {
    point?: string | undefined;
    nosology?: string | undefined;
    codeNosology?: string | undefined;
    dangerFactor?: string | undefined;
    codeExternal?: string | undefined;
}

export interface AntihypertensiveTherapyResponse {
    recommendedGroupOfDrugs?: AntihypertensiveTherapyGroupOfDrugsEnum[] | undefined;
    notRecommendedGroupOfDrugs?: AntihypertensiveTherapyGroupOfDrugsEnum[] | undefined;
    contraindicatedGroupOfDrugs?: AntihypertensiveTherapyGroupOfDrugsEnum[] | undefined;
    recommended?: string[] | undefined;
    notRecommended?: string[] | undefined;
    contraindicated?: string[] | undefined;
}

export enum AntihypertensiveTherapyGroupOfDrugsEnum {
    LoopDiuretics = 0,
    AldosteroneAntagonists = 1,
    ThiazideDiuretics = 2,
    NonDihydropyridineCalciumAntagonists = 3,
    DihydropyridineCalciumAntagonists = 4,
    BetaBlockers = 5,
    CalciumChannelBlockers = 6,
    InhibitorsOfAdenosineConvertingEnzyme = 7,
}

export interface IdValueItemOfIntegerAndString {
    id: number;
    value?: string | undefined;
}

export interface BodyMassIndexResponse {
    index: number;
    result?: string | undefined;
}

export interface CHA2DS2VAScResponse {
    result?: string[] | undefined;
}

export interface ContrastInducedNephropathyResponse {
    result?: string[] | undefined;
}

export interface CorrectedQTCalculationResponse {
    heartRate: number;
    intervalRR: number;
    bazett: number;
    fridericia: number;
    framingham: number;
    hodges: number;
    result?: string[] | undefined;
}

export interface GlasgoResponse {
    result?: string | undefined;
}

export interface GlomerularFiltrationRateResponse {
    bodyArea: number;
    cokcroftGault: number;
    cokcroftGaultTwo: number;
    mdrd: number;
    ckdepi: number;
    rewsume?: string | undefined;
    result?: string[] | undefined;
}

export interface GraceScaleResponse {
    result?: string[] | undefined;
}

export interface HASBLEDResponse {
    result?: string | undefined;
}

export interface IndexSmokeResponse {
    result?: string | undefined;
}

export interface InfusionRateResponse {
    result?: string[] | undefined;
}

export interface PotassiumDeficiencyResponse {
    index: number;
    result?: string | undefined;
}

export interface ScoreScaleResponse {
    result?: string | undefined;
    level?: string | undefined;
}

export interface SubstanceinSolutionResponse {
    result?: string[] | undefined;
}

export interface TimiScaleResponse {
    result?: string | undefined;
}

export interface CuperFormulaResponse {
    result?: string | undefined;
}

export interface DevinFormulaResponse {
    result?: string | undefined;
}

export interface EgorovaTableResponse {
    result?: string | undefined;
}

export interface HamviFormulaResponse {
    result?: string | undefined;
}

export interface BorngardtResponse {
    result?: string | undefined;
}

export interface IndexBrokaBrukshaResponse {
    result?: string | undefined;
}

export interface IndexBrokaResponse {
    result?: string | undefined;
}

export interface IndexSolovievaResponse {
    result?: string | undefined;
}

export interface KreffFormulaResponse {
    result?: string | undefined;
}

export interface LorentzFormulaResponse {
    result?: string | undefined;
}

export interface MillerFormulaResponse {
    result?: string | undefined;
}

export interface MochammedFormulaResponse {
    result?: string | undefined;
}

export interface MonnerotFormulaResponse {
    result?: string | undefined;
}

export interface NaglerFormulaResponse {
    result?: string | undefined;
}

export interface RobinsonFormulaResponse {
    result?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}

export class AccessTokenAuthClient extends AuthClient {
    constructor(apiUrl: string, private accessToken: string) {
        super(apiUrl);
    }

    transformHttpRequestOptions(options: RequestInit): Promise<RequestInit> {
        if (options.headers && this.accessToken) {
            options.headers = {...options.headers, Authorization:'Bearer ' + this.accessToken};
        }

        return super.transformHttpRequestOptions(options);
    }
}